# Benchmark suite for SuperKMeans

# Detect CPU features for FAISS optimization
# Check both compiler support AND actual flags being used
set(HAS_AVX512 OFF)
set(HAS_AVX512_SPR OFF)
set(HAS_AVX2 OFF)

if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    include(CheckCXXCompilerFlag)

    # Get all CXX flags (including build-type specific flags)
    set(ALL_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${CMAKE_BUILD_TYPE}}")
    string(TOUPPER "${CMAKE_BUILD_TYPE}" BUILD_TYPE_UPPER)
    set(ALL_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${CMAKE_CXX_FLAGS_${BUILD_TYPE_UPPER}}")

    # Check for AVX-512 support (highest priority)
    check_cxx_compiler_flag("-mavx512f" COMPILER_HAS_AVX512)
    string(FIND "${ALL_CXX_FLAGS}" "-mavx512" AVX512_IN_FLAGS)

    if(COMPILER_HAS_AVX512 OR AVX512_IN_FLAGS GREATER -1)
        set(HAS_AVX512 ON)

        # Check for Sapphire Rapids specific features
        check_cxx_compiler_flag("-mavx512fp16" COMPILER_HAS_AVX512FP16)
        string(FIND "${ALL_CXX_FLAGS}" "-mavx512fp16" AVX512FP16_IN_FLAGS)

        if(COMPILER_HAS_AVX512FP16 OR AVX512FP16_IN_FLAGS GREATER -1)
            set(HAS_AVX512_SPR ON)
            message(STATUS "Sapphire Rapids CPU detected (AVX512_FP16)")
        else()
            message(STATUS "AVX-512 CPU detected")
        endif()
    else()
        # Check for AVX2 support (fallback)
        check_cxx_compiler_flag("-mavx2" COMPILER_HAS_AVX2)
        string(FIND "${ALL_CXX_FLAGS}" "-mavx2" AVX2_IN_FLAGS)

        if(COMPILER_HAS_AVX2 OR AVX2_IN_FLAGS GREATER -1)
            set(HAS_AVX2 ON)
            message(STATUS "AVX2 CPU detected")
        else()
            message(STATUS "No AVX2/AVX-512 support detected")
        endif()
    endif()
    message(STATUS "Detected CXX flags: ${ALL_CXX_FLAGS}")
endif()

# Set FAISS optimization level based on detected CPU features
set(FAISS_OPT_LEVEL "generic")
if(HAS_AVX512_SPR)
    set(FAISS_OPT_LEVEL "avx512_spr")
elseif(HAS_AVX512)
    set(FAISS_OPT_LEVEL "avx512")
elseif(HAS_AVX2)
    set(FAISS_OPT_LEVEL "avx2")
endif()

message(STATUS "FAISS will be built with optimization level: ${FAISS_OPT_LEVEL}")

# Fetch and build FAISS
include(FetchContent)
if (MKL_FOUND)
    message(STATUS "FAISS will be built with MKL")
    set(FAISS_ENABLE_MKL ON CACHE BOOL "enable mkl" FORCE)
endif()
set(FAISS_ENABLE_PYTHON OFF CACHE BOOL "disable python" FORCE)
set(FAISS_ENABLE_GPU OFF CACHE BOOL "disable gpu" FORCE)
set(BUILD_TESTING OFF CACHE BOOL "disable faiss tests" FORCE)
set(BUILD_SHARED_LIBS ON CACHE BOOL "shared libs" FORCE)
set(FAISS_OPT_LEVEL "${FAISS_OPT_LEVEL}" CACHE STRING "CPU optimization level" FORCE)

FetchContent_Declare(
    faiss
    GIT_REPOSITORY https://github.com/facebookresearch/faiss.git
    GIT_TAG        v1.11.0
)
FetchContent_MakeAvailable(faiss)

# Common benchmark dependencies
# If MKL is found, BLAS_LINK_LIBRARIES is empty; and vice-versa
set(BENCH_COMMON_LIBS ${MKL_COMMON_LIBS} ${BLAS_LINK_LIBRARIES})
set(FAISS_COMMON_LIBS faiss)

# Link architecture-specific FAISS libraries (mutually exclusive - only the best available)
if(HAS_AVX512_SPR)
    list(APPEND FAISS_COMMON_LIBS faiss_avx512_spr)
    message(STATUS "Linking FAISS with Sapphire Rapids optimizations")
elseif(HAS_AVX512)
    message(STATUS "Linking FAISS with AVX-512 optimizations")
    list(APPEND FAISS_COMMON_LIBS faiss_avx512)
elseif(HAS_AVX2)
    message(STATUS "Linking FAISS with AVX2 optimizations")
    list(APPEND FAISS_COMMON_LIBS faiss_avx2)
else()
    message(STATUS "Linking FAISS with generic optimizations only")
endif()

if (FFTW_FOUND)
    message(STATUS "Linking FFTW: ${FFTW_FLOAT_LIB} ${FFTW_FLOAT_OPENMP_LIB}")
    list(APPEND BENCH_COMMON_LIBS ${FFTW_FLOAT_LIB} ${FFTW_FLOAT_OPENMP_LIB})
endif()

# Main benchmark: KMeans performance with synthetic data (vs FAISS)
add_executable(bench_kmeans.out bench_kmeans.cpp)
target_link_libraries(bench_kmeans.out PRIVATE ${FAISS_COMMON_LIBS} ${BENCH_COMMON_LIBS})

# Real datasets benchmark (requires dataset files generated by bench_gen.py)
add_executable(bench_real_datasets.out bench_real_datasets.cpp)
target_link_libraries(bench_real_datasets.out PRIVATE ${FAISS_COMMON_LIBS} ${BENCH_COMMON_LIBS})

# SuperKMeans benchmark on real datasets with recall computation
add_executable(end_to_end_superkmeans.out end_to_end_superkmeans.cpp)
target_link_libraries(end_to_end_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# FAISS benchmark on real datasets with recall computation
add_executable(end_to_end_faiss.out end_to_end_faiss.cpp)
target_link_libraries(end_to_end_faiss.out PRIVATE ${FAISS_COMMON_LIBS} ${BENCH_COMMON_LIBS})

# Varying K benchmarks (vary n_clusters instead of dataset)
add_executable(varying_k_superkmeans.out varying_k_superkmeans.cpp)
target_link_libraries(varying_k_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

add_executable(varying_k_faiss.out varying_k_faiss.cpp)
target_link_libraries(varying_k_faiss.out PRIVATE ${FAISS_COMMON_LIBS} ${BENCH_COMMON_LIBS})

# Early termination benchmarks
add_executable(early_termination_superkmeans.out early_termination_superkmeans.cpp)
target_link_libraries(early_termination_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

add_executable(early_termination_faiss.out early_termination_faiss.cpp)
target_link_libraries(early_termination_faiss.out PRIVATE ${FAISS_COMMON_LIBS} ${BENCH_COMMON_LIBS})

# Sampling benchmark
add_executable(sampling_superkmeans.out sampling_superkmeans.cpp)
target_link_libraries(sampling_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# Pareto benchmark (grid search)
add_executable(pareto_superkmeans.out pareto_superkmeans.cpp)
target_link_libraries(pareto_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# Ad-hoc benchmark (verbose mode, no CSV output)
add_executable(ad_hoc_superkmeans.out ad_hoc_superkmeans.cpp)
target_link_libraries(ad_hoc_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# Sweet pruning spot benchmark (grid search over pruning parameters)
add_executable(sweet_pruning_spot_superkmeans.out sweet_pruning_spot_superkmeans.cpp)
target_link_libraries(sweet_pruning_spot_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# Pruning bailout analysis benchmark (compare with_pruning vs blas_only)
add_executable(pruning_bailout_analysis_superkmeans.out pruning_bailout_analysis_superkmeans.cpp)
target_link_libraries(pruning_bailout_analysis_superkmeans.out PRIVATE ${BENCH_COMMON_LIBS})

# Microbenchmark for InitPositionsArray SIMD optimization
add_executable(microbenchmark_init_positions_array.out microbenchmark_init_positions_array.cpp)
target_link_libraries(microbenchmark_init_positions_array.out PRIVATE ${BENCH_COMMON_LIBS})

# Microbenchmark for FlipSign SIMD optimization
add_executable(microbenchmark_flip_sign.out microbenchmark_flip_sign.cpp)
target_link_libraries(microbenchmark_flip_sign.out PRIVATE ${BENCH_COMMON_LIBS})

# Microbenchmark for Horizontal L2 distance kernels
add_executable(microbenchmark_horizontal_kernels.out microbenchmark_horizontal_kernels.cpp)
target_link_libraries(microbenchmark_horizontal_kernels.out PRIVATE ${BENCH_COMMON_LIBS})

# Correctness test for DCT rotation
add_executable(test_dct_rotation_correctness.out test_dct_rotation_correctness.cpp)
target_link_libraries(test_dct_rotation_correctness.out PRIVATE ${BENCH_COMMON_LIBS})
