#undef HAS_FFTW

#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <omp.h>
#include <vector>

#include "superkmeans/hierarchical_superkmeans.h"
#include "superkmeans/common.h"
#include "superkmeans/pdx/utils.h"

int main() {
    constexpr size_t N_SAMPLES = 10000;
    constexpr size_t MAX_D = 768;
    constexpr size_t N_TRUE_CENTERS = 500;
    constexpr float CLUSTER_STD = 0.25f;
    constexpr float CENTER_SPREAD = 5.0f;
    constexpr unsigned int SEED = 42;
    constexpr int ITERS_MESOCLUSTERING = 5;
    constexpr int ITERS_FINECLUSTERING = 5;
    constexpr int ITERS_REFINEMENT = 2;

    std::vector<size_t> k_values = {10, 100, 250};
    std::vector<size_t> d_values = {4, 16, 32, 64, 100, 128, 384, 512, 600, 768};

    omp_set_num_threads(1);

    // Load test data from disk (generated by generate_wcss_ground_truth.out)
    std::vector<float> full_data(N_SAMPLES * MAX_D);
    std::string data_file = CMAKE_SOURCE_DIR "/tests/test_data.bin";
    std::ifstream in(data_file, std::ios::binary);
    if (!in) {
        std::cerr << "Error: Could not open " << data_file << "\n";
        std::cerr << "Run generate_wcss_ground_truth.out first to generate test_data.bin\n";
        return 1;
    }
    in.read(reinterpret_cast<char*>(full_data.data()), full_data.size() * sizeof(float));
    in.close();
    std::cerr << "Loaded test data from " << data_file << "\n\n";

    auto extract_subdim = [&](size_t d) -> std::vector<float> {
        std::vector<float> data(N_SAMPLES * d);
        for (size_t i = 0; i < N_SAMPLES; ++i) {
            std::memcpy(&data[i * d], &full_data[i * MAX_D], d * sizeof(float));
        }
        return data;
    };

    std::cout << std::scientific << std::setprecision(5);
    std::cout << "// Ground truth WCSS values for test_hierarchical_superkmeans.cpp\n";
    std::cout << "// Generated with: N_SAMPLES=" << N_SAMPLES << ", MAX_D=" << MAX_D
              << ", N_TRUE_CENTERS=" << N_TRUE_CENTERS << ", CLUSTER_STD=" << CLUSTER_STD
              << ", CENTER_SPREAD=" << CENTER_SPREAD << ", SEED=" << SEED
              << ", ITERS_MESOCLUSTERING=" << ITERS_MESOCLUSTERING
              << ", ITERS_FINECLUSTERING=" << ITERS_FINECLUSTERING
              << ", ITERS_REFINEMENT=" << ITERS_REFINEMENT << "\n";
    std::cout << "// Test data loaded from: tests/test_data.bin\n";
    std::cout << "// Copy-paste the following into GROUND_TRUTH map:\n\n";

    for (size_t k : k_values) {
        std::cout << "    // k=" << k << "\n";
        for (size_t d : d_values) {
            auto data = extract_subdim(d);

            // These config values MUST match those in test_hierarchical_superkmeans.cpp
            skmeans::HierarchicalSuperKMeansConfig config;
            config.iters_mesoclustering = ITERS_MESOCLUSTERING;
            config.iters_fineclustering = ITERS_FINECLUSTERING;
            config.iters_refinement = ITERS_REFINEMENT;
            config.verbose = false;
            config.seed = SEED;
            config.early_termination = false;
            config.sampling_fraction = 1.0f;
            config.max_points_per_cluster = 99999;
            config.min_not_pruned_pct = 0.03f;
            config.max_not_pruned_pct = 0.05f;
            config.adjustment_factor_for_partial_d = 0.20f;
            config.angular = false;
            config.n_threads = 1;

            auto kmeans =
                skmeans::HierarchicalSuperKMeans<skmeans::Quantization::f32, skmeans::DistanceFunction::l2>(
                    k, d, config
                );
            kmeans.Train(data.data(), N_SAMPLES);

            // Final WCSS: refinement stats if available, otherwise last fineclustering stat
            float wcss;
            const auto& hierarchical_stats = kmeans.hierarchical_iteration_stats;
            if (!hierarchical_stats.refinement_iteration_stats.empty()) {
                wcss = hierarchical_stats.refinement_iteration_stats.back().objective;
            } else {
                wcss = hierarchical_stats.fineclustering_iteration_stats.back().objective;
            }
            std::cout << "    {{" << k << ", " << d << "}, " << wcss << "f},\n";
        }
    }
    return 0;
}
